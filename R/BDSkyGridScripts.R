#' Reads a log file
#' 
#' @param filename The name of the file (with the path if necessary)
#' @param burnin The burnin to remove from the log in proportion
#' @return A data.table
read.log <- function (filename, burnin = 0.1) 
{
  logfile <- data.table::fread(cmd=paste("grep -v '^#'",filename))
  n <- nrow(logfile)
  if(all(is.na(logfile[[ncol(logfile)]]))) logfile <- logfile[, -ncol(logfile), with=FALSE]
  return(logfile[floor(burnin * n):n, ])
}

#' Extract a parameter from HPD using a regular expression
#' 
#' @param  HPD The HPD table (obtained with extract.HPD)
#' @param param The name (pattern) to use in the regular expression
#' @return A data.table
extract.param <- function(HPD, param) {
  param <- HPD[grep(param, HPD[, Param]), ]
  return(param)
}

#' Extract the Highest Probability Density (HPD) from logged data
#' 
#' This function uses boa::boa.hpd
#' 
#' @param log The log (read with read.log)
#' @param alpha The credibility interval (between 0 and 1)
#' @importFrom boa boa.hpd
#' @return A data.table with HPD (lower and upper limits, and median)
extract.HPD <- function(log, alpha=0.05) {
  HPD <- log[, lapply(.SD, boa::boa.hpd, alpha)]
  Median <- log[, lapply(.SD, median)]
  HPD <- rbind(HPD, Median)
  # HPD <- log[, lapply(.SD, quantile, probs=c(0 + alpha/2, 0.5, 1 - alpha/2))]
  HPD <- transpose(HPD, keep.names = "Param")
  setnames(HPD, c("Param", "Lower", "Upper", "Median"))
  setcolorder(HPD, c("Param", "Lower", "Median", "Upper"))
  return(HPD)
}

#' Generate the starting and ending times of the epochs
#'
#' skygrid reports as first parametr the most recent, so needs \code{reverse=TRUE}.
#' 
#' @param maxAge The age of the most recent sample.
#' @param gridPoints The times used in the analysis as gridPoints (skygrid) or
#'   changeTimes (BD models)
#' @param rootHeight The median value of the rootHeight
#' @param reverse When \code{FALSE}, the epoch in the log are from the oldest to
#'   the youngest (that is, the first entry for the parameter is for the oldest
#'   epoch). If \code{TRUE} the epoch in the log are from the youngest to the
#'   oldest.
#' @inheritParams extract.HPD
#' @return A data.table
make.epochs.data <- function(HPD, maxAge, gridPoints, rootHeight, reverse=FALSE) {
  if(reverse ==TRUE) {
    Time <- c(maxAge, maxAge - gridPoints, maxAge - rootHeight)
    epochs <- HPD[, `:=`(TimeMin=tail(Time, -1), TimeMax=head(Time, -1))]
  } else {
    Time <- c(maxAge - rootHeight, maxAge - gridPoints, maxAge)
    epochs <- HPD[, `:=`(TimeMin=head(Time, -1), TimeMax=tail(Time, -1))]
  }
  return(epochs)
}

#' Generate a skyline plot
#'
#' If more than one set of data are passed, the function will overimpose each
#' set in the same plot. In this case, the data have to be in a list, with each
#' data.table as an element of the list, and an additional column needs to be
#' added to the data. This column, whose name has to be passed with the argument
#' \code{by}, will be used to colourcode the plot and identify the datasets.
#'
#' The plot returned by the function is a ggplot object and can, therefore, be
#' modified as usual (e.g. \code{plot + theme_classic()})
#'
#' @param epochData The starting and ending times of the epochs (generated with
#'   make.epochs.data) or a list (see Details)
#' @param  by the column's name to use to colourcode the skylines
make.skyplot <- function(epochData, by=NULL) {
  proc.data <- function(epochData) {
    if(nrow(epochData) == 1) stop("There is only one epoch in the data")
    if(epochData[1, TimeMin] > epochData[2, TimeMin]) {
      newepoch <- rbind(epochData[1,], epochData)
      newepoch[1, TimeMin := newepoch[1, TimeMax]]
    } else {
      newepoch <- rbind(epochData, epochData[nrow(epochData),])
      newepoch[nrow(epochData), TimeMin := newepoch[nrow(epochData), TimeMax]]
    }
    return(newepoch)
  }
  if(is.list(epochData) && !is.data.table(epochData)) {
    newepoch <- lapply(epochData, proc.data)
    newepoch <- rbindlist(newepoch)
  } else {
    newepoch <- proc.data(epochData)
  }
  skyplot <- ggplot(newepoch, aes_string(col=by, fill=by)) + 
    geom_rect(aes(xmin=TimeMin, xmax=TimeMax, ymin=Lower, ymax=Upper), alpha=0.5) +
    geom_step(aes(TimeMin, Median))
  return(skyplot)
}


#' Produce a skylie plot starting from a BDMM-prime MCMC log
#'
#' This function deals with parameters that change over time within each deme
#' (e.g. R0, s), not between demes (e.g. migration R0AmongDemes).
#'
#' It returns a ggplot with overimposed (with transperancy) plot colour-coded
#' for each deme. This can be edited post-production as usual for
#' ggplot-objects. For example, if multiple plots - one for each deme - are
#' needed, this can be easily achieved with \code{facet_grid} (say the plot generated by \code{make.BDMMbydeme.skyplot} is p, you could use :
#' \code{p + facet_grid(Deme~.)} to have each deme on separate rows).
#'
#' @param par the parameter to be plotted. Possible option: "R0", "s" (sampling
#'   proportion), "delta" (becomingUninfectiousRate), "r" (removevalProbability)
#' @param nBins the number of bins to use (integer of length=1)
#' @param type The type of plot to generate. This will depend on how the
#'   analysis has been set up: "smooth" if the timeChanges parameters are
#'   estimated; "step" is these are fixed.
#' @inheritParams make.epochs.data,extract.HPD
#' @import data.table,ggplot2
#' @importFrom boa::boa.hpd
#' @export
#' 
make.BDMMbyDeme.skyplot <- function(log, par=c("R0", "s", "delta", "r"), nBins=100,
                                    type=c("smooth", "step"), alpha=0.05, maxAge) {
  param <- match.arg(par)
  switch(param, R0=param <- "R0SVEpi", s=param <- "samplingProportionSVEpi", 
         delta=param <- "becomeUninfectiousRateSVEpi", r=param <- "removalProbSVEpi")
  type <- match.arg(type)
  
  dat <- log[, grep(param, names(log)), with=FALSE]
  
  matches <- regexec(paste0(param,"\\.i[0-9]+_"), names(dat))
  starts <- sapply(matches, attr, "match.length") + 1
  demes <- substring(names(dat), starts)
  demes <- unique(demes[grep("endtime", demes, invert = TRUE)])
  nDemes <- length(demes)
  dat_demes <- lapply(demes, extract.cols, dt=dat)
  endtimes <- as.matrix(dat[, grep("endtime", names(dat)), with=FALSE])
  origins <- log[, originBDMMPrime]
  
  hpd <- vector("list", length = nDemes)
  if(type == "smooth") {
    parByGrid_demes <- vector("list", length = nDemes)
    for(d in seq_len(nDemes)) {
      parByGrid_demes[[d]] <- matrix(nrow = nrow(endtimes), ncol = nBins)
    }
    for(d in seq_len(nDemes)) {
      for(rn in seq_len(nrow(endtimes))) {
        x <- seq(0, origins[rn],  length.out = nBins)
        br <- c(0, endtimes[rn,], origins[rn])
        parByGrid_demes[[d]][rn, ] <- as.numeric(dat_demes[[d]][rn, 
                                                                .bincode(x, br, TRUE, TRUE), 
                                                                with=FALSE])
        
      }
    }
    
    hpd1col <- vector("list", length = nDemes)
    medians <- vector("list", length = nDemes)
    for(d in seq_len(nDemes)) {
      hpd[[d]] <- apply(parByGrid_demes[[d]], 2, boa::boa.hpd, alpha = alpha)
      hpd[[d]] <- t(hpd[[d]])
      hpd1col[[d]] <- c(hpd[[d]][, 1], rev(hpd[[d]][,2]))
      medians[[d]] <- c(apply(parByGrid_demes[[d]], 2, median), rev(apply(parByGrid_demes[[d]], 2, median)))
    }
    hpd1col <- lapply(hpd1col, data.table)
    names(hpd1col) <- demes
    hpd1col <- rbindlist(hpd1col, idcol = "Deme")
    hpd1col[, Median := do.call(c, medians)]
    setnames(hpd1col, "V1", "Param")
    times <- seq(0, median(origins),  length.out = nBins)
    ages <- maxAge - median(origins) + times
    hpd1col[, Times := rep(c(times, rev(times)), 4)]
    hpd1col[, Age := rep(c(ages, rev(ages)), 4)]
    skyplot <- ggplot(hpd1col, aes(x = Age, y=Param, col=Deme, fill=Deme)) + 
      geom_polygon(alpha=0.5) +
      geom_line(aes(Age, Median)) #+ facet_grid(Deme~.)
  } else {
    epochs <- vector("list", length = nDemes)
    for(d in seq_len(nDemes)) {
      hpd[[d]] <- extract.HPD(dat_demes[[d]], alpha = alpha)
     epochs[[d]] <- make.epochs.data(hpd[[d]], maxAge = maxAge, 
                                     gridPoints = median(origins) - apply(endtimes, 2, median), 
                                     rootHeight = median(origins))
     epochs[[d]][, Deme :=rep(demes[d], nrow(epochs[[d]]))]
    }
    skyplot <- make.skyplot(epochs, by = "Deme") #+ facet_grid(Deme~.)
  }
  return(skyplot)
}



extract.cols <- function(dt, param) {
  newdt <- dt[, grep(param, names(dt)), with=FALSE]
  return(newdt)
}

#' Draw violin plot for each deme and epoch
#'
#' This function generates a violin plot with each deme is plotted (and
#' colour-coded) separately. Each Epoch is plotted as one line in the plot.
#'
#' Within the violin plot there are tree lines, the two most external lines mark
#' the 2.5 and 97.5 percentile. The middle one is the median.
#'
#' The object returned is a ggplot object, which can be modified as usual. For
#' example, in presence of long tails, one may want to trim the y axis like so:
#' \code{p + ylim(c(l, u))}, where p is the plot returned by the function, and
#' \code{l} and \code{u] are the lower and upper desire limits on the y axis. It
#' is important to also note that the first element of the ggplot list returned
#' are the actual data that are used to generate the plot, which can then be
#' used for other down-stream analysis or plots.
#'
#' @param keepScale Whether the y axis should be kept consistent (TRUE) across
#'   all rows of the plot or adjusted depending on the posterior distribution
#'   (FALSE). The second is sometime more convenient for readability.
#' @inheritParams  make.BDMMbyDeme.skyplot
#' @return a ggplot
#' @import data.table
#' @export
make.BDMMbyDeme.violin <- function(log, par=c("R0", "s", "delta", "r"), keepScale=TRUE) {
  param <- match.arg(par)
  switch(param, R0=param <- "R0SVEpi", s=param <- "samplingProportionSVEpi", 
         delta=param <- "becomeUninfectiousRateSVEpi", r=param <- "removalProbSVEpi")
  
  dat <- log[, grep(param, names(log)), with=FALSE]
  
  matches <- regexec(paste0(param,"\\.i[0-9]+_"), names(dat))
  starts <- sapply(matches, attr, "match.length") + 1
  demes <- substring(names(dat), starts)
  demes <- unique(demes[grep("endtime", demes, invert = TRUE)])
  nDemes <- length(demes)
  dat_demes <- lapply(demes, extract.cols, dt=dat)
  
  process.epochs <- function(dt, param, par) {
    dt2 <- melt.data.table(dt, measure.vars = patterns(param), 
                           variable.name = "Epoch", value.name = par)
    starts <- regexec(paste0(param,"\\.i"), dt2[, Epoch])
    starts <- sapply(starts, attr, "match.length")
    ends <- regexec(paste0(param,"\\.i[0-9]+"), dt2[, Epoch])
    ends <- sapply(ends, attr, "match.length")
    dt2[, Epoch := substr(Epoch, starts + 1, ends)]
    return(dt2)
  }
  dat_demes <- lapply(dat_demes, process.epochs, param=param, par=par)
  names(dat_demes)  <- demes
  dat_fin <- rbindlist(dat_demes, idcol = "Deme")
  
  viol_plot <- ggplot(data=dat_fin, aes_string("Deme", par, fill="Deme")) + 
    geom_violin(draw_quantiles=c(0.025, 0.5, 0.975)) +
    facet_grid(Epoch~., scales = if(keepScale) "fixed" else "free_y")
  
  
  return(viol_plot)
}







































